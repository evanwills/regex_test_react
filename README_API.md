# Regex tester API

## Requests

The API handles 3 types of calls:
* __`validate`__ check if regex is valid
* __`test`__ applies all supplied regex against all supplied inputs in order and returns whatever is match by each regex for each input
* __`replace`__ does a find and replace on each input using each regex in order

-----

### `validate`

`validate` only test a single regex to see if it is valid. If not, it'll return the error generated by the regex

#### `validate` Request:

`validate` requests have two POST fields:

* "`action`" with a value of "`validate`"
* "`regex`" containing a JSON object with the following structure 
``` json
{
  "delimiterClose": "",
  "delimiterOpen": "",
  "modifiers": "",
  "regex": "",
}
```

* `delimiterClose` the closing delimiter for the regex
* `delimiterOpen` the closing delimter for the regex
* `modifiers` any modifiers (aka flags) to be applied to the regex
* `regex` the regex itself (without delimiters)

NOTE: open and close delimiters are separated out because some regex engines (like Javascript's RegExp object) don't require delimiters

The API uses whichever parts of the regex object it needs to build what it needs

### `validate` Response
After validation the API returns an APIresponse with the `content` being a `ValidatedRegex` object

If the regex is valid, it `content` will contain the simple form of `ValidatedRegex`:

``` JSON
{
  "ok": true,
  "code": 1,
  "content": { "valid": true },
  "returnType": "ValidatedRegex"
}
```

If the regex is invalid, it `content` will contain the simple form of `ValidatedRegex`:

``` JSON
{
  "ok": true,
  "code": 1,
  "content": {
    "valid": false,
    "error": {
      "rawMessage": "",
      "message": "",
      "offset": -1,
      "badCharacter": ""
    }
  },
  "returnType": "ValidatedRegex"
}
```
* `rawMessage` is the message returned by the regex engine.
* `message` is a parsed and improved version of the message
* `offset` is where the error occured
* `badCharacter` is the character that caused the issue (if known)

-----

## __`test`__

Test takes an array of inputs and an array of regexes and tests each input againts all the regexes

### `test` Request

#### Mandatory `POST` fields

`test` requests have three mandatory POST fields:

* "`action`" with a value of "`test`"
* "`inputs`" containing a JSON array of strings to be used to test the regex against. `inputs` must have the following structure
``` JSON
[
  "input strings"
]
```



* "`regexes`" containing a JSON array cotaining (RegexPair) objects with the following structure 
``` JSON
[
  {
    "delimiterClose": "",
    "delimiterOpen": "",
    "doReplaceOnTest": true,
    "id": 1,
    "modifiers": "",
    "regex": "",
    "replace": "",
    "transformWhitespaceCharacters": true
  }
]
```

* `delimiterClose` the closing delimiter for the regex
* `delimiterOpen` the closing delimter for the regex
* `doReplaceOnTest` (optional - default `true`) whether to find/replace for each regex so the next regex has the input updated by the previous regex
* `id` the ID of the regex (as creted on the front end)
* `modifiers` any modifiers (aka flags) to be applied to the regex
* `regex` the regex itself (without delimiters)
* `transformWhitespaceCharacters` (optional - default `true`) whether to transform the with space escape characters "`\t`", "`\r`", "`\n`" & "`\f`" into their proper whitespace equivelents

#### Optional `POST` fields

`test` requests have two optional POST fields:

* "`maxSampleLength`" (optional - default: 300) an integer greater than 10 which defines the maximum length of the "whole" match (e.g. say `maxSampleLength is 300 (the default) and the whole matched string is 450 characters the returned match string will be truncated to 300 characters and have "..." appended to it to show it was truncated)
* "`maxSubPatternLength`"  (optional - default: 300) an integer greater than 10 which defines the maximum length of captured sub pattern strings

These help improve the response time if you doing find/replace on large chuncks of text

### `test` Response

The `test` response will be a JSON array of `RegexTestResult` objects. One for each input/regex conbination

#### Results for valid regexes

``` JSON
{
  "ok": true,
  "code": 1,
  "content": [
    {
      "error": { "valid": true },
      "inputID": 1,
      "matches": [],
      "regexID": 1,
      "executionTime": 0.0001
    }
  ],
  "returnType": "RegexTestResult"
}
```
A valid regex will have the following `RegexTestResult` structure

``` JSON
{
  "error": { "valid": true },
  "inputID": 1,
  "matches": [],
  "regexID": 1,
  "executionTime": 0.0001
}
```

* `error` contains a `ValidatedRegex` object.
* `inputID` is the index of the input that was tested
* `regexID` is the index of the input that was tested
* `executionTime` the number of miliseconds it took to do the matching
* `matches` will contain an array of `RegexMatch` objects. One for every string match made in that input. `RegexMatch` object have the following structure 

``` JSON
{
  "whole": "",
  "parts": {},
  "position": 0
}
```

* `whole` is the whole string that was matched
* `parts` indexed and named captured sub-patterns matched as part of the whole match
* `position` offset index (from the begining of the input) of the start of the whole string


-----

## __`replace`__

`replace` takes an array of inputs and an array of regexes and applies each regex find & replace to each input

### `replace` Request

A `replace` is almost identical to a `test` request except action POST field's value is `replace` and the optional POST fields `maxSampleLength` & `maxSubPatternLength` are ignored if supplied.


#### Mandatory `POST` fields

`test` requests have three mandatory POST fields:

* "`action`" with a value of "`test`"
* "`inputs`" containing a JSON array of strings to be used to test the regex against. `inputs` must have the following structure
``` JSON
[
  "input strings"
]
```

* "`regexes`" containing a JSON array cotaining (RegexPair) objects with the following structure 
``` JSON
[
  {
    "delimiterClose": "",
    "delimiterOpen": "",
    "doReplaceOnTest": true,
    "id": 1,
    "modifiers": "",
    "regex": "",
    "replace": "",
    "transformWhitespaceCharacters": true
  }
]
```

* `delimiterClose` the closing delimiter for the regex
* `delimiterOpen` the closing delimter for the regex
* `id` the ID of the regex (as creted on the front end)
* `modifiers` any modifiers (aka flags) to be applied to the regex
* `regex` the regex itself (without delimiters)
* `transformWhitespaceCharacters` (optional - default `true`) whether to transform the with space escape characters "`\t`", "`\r`", "`\n`" & "`\f`" into their proper whitespace equivelents
