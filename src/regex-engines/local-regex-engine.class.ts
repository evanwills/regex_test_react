import { XRegExp, match } from 'XRegExp'
import { RegexEngine } from './regex-engine.class'
import {IConstructedRegex, IDelimPair, IRegexConfig, IRegexMatch, IRegexPair, IRegexTestGlobal, IRegexTestResult, IValidatedRegex} from './regex-engine.interfaces'

interface ILocalRegexMatch extends RegexMatch {
  parts: Array<string>
}
interface RegExpResult {
  matches: Array<string>,
  lastIndex: number
}

export class LocalRegex extends RegexEngine {
  constructor (engine: IRegexConfig) {
    super(engine);
  }

  /**
   * LocalRegex::isValid() tests the supplied regex to see if it is
   * valid and returns any error message generated by invalid regex
   *
   * @param regex a raw regular expression without delimiters or
   *              modifiers/flags
   * @param modifiers a list of modifiers/flags to augment the
   *              regex's behavior
   * @param delimiters (not used by localRegex) delimiter character
   *              to mark the begining and end of the regex
   *              (and separate the regex form the modifiers/flags)
   * @returns an empty string if the regex is valid or the error
   *              message generated by the invalid regex
   */
  public isValid(regex: string, modifiers: string, delimiters?: IDelimPair) : string {
    let tmp;
    try {
      tmp = this._getRegexObject(regex, modifiers);
    } catch(e) {
      return e;
    }
    return '';
  }

  /**
   * LocalRegex::replace() applies regexes to strings and updates
   * them using the regex's replace string
   *
   * @param input an array of one (or more) strings to which all of
   *              the (one or more) supplied regular expressions
   *              are applied
   * @param regexes an array of one (or more) regular expressions to
   *              which all of the (one or more) input strings
   *              are applied
   * @returns an array of updated input strings changed by each
   *              successive supplied regex
   */
  public replace(input: Array<string>, regexes: Array<RegexPair>) : Array<string> {
    let output = [];
    let constructedRegexes = this._getConstructedRegexes(regexes);

    for (let a = 0; a < input.length; a += 1) {
      let tmp = input[a];
      for (let b = 0; b < constructedRegexes.length; b += 1) {
        if (constructedRegexes[b].error['valid'] === true) {
          tmp = tmp.replace(
            constructedRegexes[b].find,
            constructedRegexes[b].replace
          );
        }
      }
      output.push(tmp);
    }

    return output;
  }

  /**
   * LocalRegex::test() applies regexes to strings to see what is
   * matched in that string using that regex
   *
   * @param input an array of one (or more) strings to which all of
   *              the (one or more) supplied regular expressions
   *              are applied
   * @param regexes an array of one (or more) regular expressions to
   *              which all of the (one or more) input strings
   *              are applied
   * @returns an array of regex test results
   */
  public test(input: Array<string>, regexes: Array<RegexPair>) : Array<RegexTestResult> {
    let output = [];
    let constructedRegexes = this._getConstructedRegexes(regexes);

    for (let a = 0; a < input.length; a += 1) {
      let tmp = input[a];
      for (let b = 0; b < constructedRegexes.length; b += 1) {
        let error : ValidatedRegex = constructedRegexes[b].error;
        let results : regexTestGlobal = {
          matches: [],
          execTime: 0
        };
        let ok : boolean = false;

        if (constructedRegexes[b].error['valid'] !== false) {
          if (constructedRegexes[b].find.global === true) {
            results = this._regexTestGlobal(constructedRegexes[b].find, tmp);
            ok = true;
          } else {
            let startTime = Date.now();
            let matches = constructedRegexes[b].find.exec(tmp);
            let execTime = Date.now() - startTime;
            if (matches !== null) {
              results = {
                matches: [this._regexTestInner(matches)],
                execTime: execTime
              }
              ok = true;
            }
          }

          // apply the find/replace to the current input so if the
          // next regex relies on this change it'll work.
          tmp = tmp.replace(
            constructedRegexes[b].find,
            constructedRegexes[b].replace
          );
        }

        output.push({
          error: error,
          executionTime: results['execTime'],
          inputID: a,
          matches: results['matches'],
          regexID: constructedRegexes[b].regexID
        });
      }
    }

    return output;
  }

  /**
   * Generic function that builds a list of reusable RegExp objects
   * that can be used either for testing or for replacing
   *
   * @param regexes a list of one or more regular expression pairs
   */
  protected _getConstructedRegexes(regexes: Array<RegexPair>) : Array<ConstructedRegex> {
    let output = [];
    for (let a = 0; a < regexes.length; a += 1) {
      let tmpRegexp;
      let isValid : ValidatedRegex = {
        valid: true,
        error: null
      }
      try {
        tmpRegexp = this._getRegexObject(regexes[a].regex, regexes[a].modifiers);
      } catch(e) {
        isValid.error = {
          rawMessage: e,
          message: '',
          offset: -1,
          badCharacter: '',
          regexID: regexes[a].id
        };
        isValid.valid = false;
      }
      output.push({
        error: isValid,
        find: tmpRegexp,
        regexID: regexes[a].id,
        replace: regexes[a].replace
      })
    }
    return output;
  }

  /**
   * localRegex::_getRegexObject() returns a single regular
   * expression object that can be used for testing or replacing
   *
   * @param regex string to be used as a regular expression.
   * @param modifiers string of modifiers/flags to augment the
   *              behavior of the regex
   */
  protected _getRegexObject(regex: string, modifiers: string) : RegExp {
    let output : RegExp;
    try {
      output = new RegExp(regex, modifiers);
    } catch (e) {
      throw new Error(e);
    }
    return output;
  }

  /**
   * _regexTestGlobal() builds an array of RegexMatch objects created by a RegExp object with the Global flag set
   *
   * @param regex RegExp object
   * @param input string to be tested against the regex
   */
  protected _regexTestGlobal(regex: RegExp, input: string) : regexTestGlobal {
    let output = []
    // let output2 = []
    let matches
    let ellapsedTime = 0;
    let startTime = Date.now();
    let matchCount = 0;
    while ((matches = regex.exec(input)) !== null) {
      ellapsedTime += (Date.now() - startTime);

      let newMatch:RegexMatch = this._regexTestInner(matches);
      newMatch.position = regex.lastIndex - matches[0].length;
      output.push(newMatch);

      matchCount += 1;
      startTime = Date.now();
    }
    return {
      matches: output,
      execTime: ellapsedTime
    }
  }

  /**
   * localRegex::_sanitiseForRegex() takes a string and makes it safe
   * to use as part of a regex
   *
   * @param input string to be sanitised for later use in a regex
   * @returns a string that can be incorporated into a regex without
   *              any impact on that regex.
   */
  protected _sanitiseForRegex(input: string) : string {
    return input.replace(/([\[\]{}^$()?*+|])/ig, '\\$1')
  }


  /**
   * LocalRegex::_regexTestNonGlobal() builds an array of zero or one
   * RegexMatch objects created by a RegExp object with no Global
   * flag set
   *
   * @param regex RegExp object
   * @param input string to be tested against the regex
   */
  protected _regexTestNonGlobal(regex: RegExp, input: string) : regexTestGlobal {
    let output : regexTestGlobal = {
      matches: [],
      execTime: 0
    };
    let startTime = Date.now();
    let tmp = regex.exec(input);

    output.execTime = (Date.now() - startTime);

    if (tmp !== null) {
      let newMatch:RegexMatch;
      newMatch = this._regexTestInner(tmp);

      let offsetRegex = new RegExp('^(.*?)' + this._sanitiseForRegex(newMatch.whole) + '.*$')
      let lead = input.replace(offsetRegex, '$1');

      newMatch.position = lead.length;
      output.matches.push(newMatch);
    }

    return output;
  }

  /**
   * LocalRegex::_regexTestInner() builds a RegexMatch object from what is returned
   * by RegExp.exec()
   *
   * @param matches object returned by RegExp.prototype.exec()
   */
  protected _regexTestInner(matches: RegExpExecArray) : RegexMatch {
    let newMatch : RegexMatch = {
      whole: matches[0],
      parts: {},
      position: 0
    };
    for (let a = 0; a < matches.length; a += 1) {
      if (a > 0) {
        let b = "" + a;
        newMatch.parts[b] = matches[a];
      }
    }

    return newMatch
  }
}


export class VanillaJSregex extends LocalRegex {
}


export class XRegExpRegex extends LocalRegex {
  /**
   * XRegExpRegex::_getRegexObject() returns a single regular
   * expression object that can be used for testing or replacing
   *
   * NOTE: the returned is not a standard ECMAscript RegExp object.
   *       It's one augmented by XRegExp and so can do fancier things.
   *
   * @param regex string to be used as a regular expression.
   * @param modifiers string of modifiers/flags to augment the
   *              behavior of the regex
   */
  protected _getRegexObject(pattern: string, modifiers: string) : any {
    let output;
    try {
      output = XRegExp(pattern, modifiers);
    } catch (e) {
      throw new Error(e);
    }
    return output;
  }
}
